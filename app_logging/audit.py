"""
Audit Logging Module
Immutable audit trails for HIPAA/SOC2/GDPR compliance

Features:
- Immutable log entries
- Cryptographic signatures
- Tamper detection
- Regulatory compliance

Generated by inquantic-foundry
"""

import json
import hashlib
from datetime import datetime
from typing import Any, Dict, Optional
from pathlib import Path

from config.settings import settings
from app_logging.logger import get_logger

logger = get_logger(__name__)


# ============================================================================
# AUDIT LOG ENTRY
# ============================================================================

class AuditLogEntry:
    """
    Immutable audit log entry with cryptographic chaining.
    """

    def __init__(
            self,
            event_type: str,
            actor: str,
            resource: str,
            action: str,
            result: str,
            details: Optional[Dict[str, Any]] = None,
            previous_hash: Optional[str] = None
    ):
        self.timestamp = datetime.utcnow().isoformat() + "Z"
        self.event_type = event_type
        self.actor = actor  # User ID or system component
        self.resource = resource  # What was accessed
        self.action = action  # What action was performed
        self.result = result  # success, failure, denied
        self.details = details or {}
        self.previous_hash = previous_hash
        self.hash = self._compute_hash()

    def _compute_hash(self) -> str:
        """
        Compute cryptographic hash of log entry.
        Creates tamper-evident chain of log entries.
        """
        data = {
            "timestamp": self.timestamp,
            "event_type": self.event_type,
            "actor": self.actor,
            "resource": self.resource,
            "action": self.action,
            "result": self.result,
            "details": self.details,
            "previous_hash": self.previous_hash
        }

        serialized = json.dumps(data, sort_keys=True)
        return hashlib.sha256(serialized.encode()).hexdigest()

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage"""
        return {
            "timestamp": self.timestamp,
            "event_type": self.event_type,
            "actor": self.actor,
            "resource": self.resource,
            "action": self.action,
            "result": self.result,
            "details": self.details,
            "previous_hash": self.previous_hash,
            "hash": self.hash
        }

    def to_json(self) -> str:
        """Convert to JSON string"""
        return json.dumps(self.to_dict())


# ============================================================================
# AUDIT LOGGER
# ============================================================================

class AuditLogger:
    """
    Manages immutable audit logs with cryptographic chaining.
    """

    def __init__(self, log_file: str = None):
        self.log_file = Path(log_file or settings.AUDIT_LOG_FILE)
        self.log_file.parent.mkdir(parents=True, exist_ok=True)
        self.last_hash: Optional[str] = None
        self._load_last_hash()

    def _load_last_hash(self):
        """Load hash of last log entry for chaining"""
        if not self.log_file.exists():
            return

        try:
            with open(self.log_file, 'r') as f:
                # Read last line
                lines = f.readlines()
                if lines:
                    last_entry = json.loads(lines[-1])
                    self.last_hash = last_entry.get("hash")
        except Exception as e:
            logger.error("failed_to_load_last_hash", error=str(e))

    def log(
            self,
            event_type: str,
            actor: str,
            resource: str,
            action: str,
            result: str,
            details: Optional[Dict[str, Any]] = None
    ):
        """
        Write audit log entry.

        Args:
            event_type: Type of event (e.g., "data_access", "authentication")
            actor: Who performed the action (user ID or system)
            resource: What was accessed (e.g., "patient:123", "transaction:456")
            action: Action performed (e.g., "read", "write", "delete")
            result: Outcome (e.g., "success", "failure", "denied")
            details: Additional context
        """
        if not settings.AUDIT_LOG_ENABLED:
            return

        entry = AuditLogEntry(
            event_type=event_type,
            actor=actor,
            resource=resource,
            action=action,
            result=result,
            details=details,
            previous_hash=self.last_hash
        )

        # Write to file (append-only)
        try:
            with open(self.log_file, 'a') as f:
                f.write(entry.to_json() + '\n')

            # Update last hash for next entry
            self.last_hash = entry.hash

            logger.info(
                "audit_log_written",
                event_type=event_type,
                actor=actor,
                resource=resource,
                action=action,
                result=result
            )

        except Exception as e:
            logger.error(
                "audit_log_write_failed",
                error=str(e),
                event_type=event_type
            )

    def verify_integrity(self) -> bool:
        """
        Verify integrity of audit log chain.

        Returns:
            True if log chain is intact, False if tampered
        """
        if not self.log_file.exists():
            return True

        try:
            with open(self.log_file, 'r') as f:
                lines = f.readlines()

            previous_hash = None
            for i, line in enumerate(lines):
                entry_dict = json.loads(line)

                # Verify previous hash matches
                if entry_dict.get("previous_hash") != previous_hash:
                    logger.error(
                        "audit_log_integrity_failure",
                        line_number=i + 1,
                        reason="previous_hash_mismatch"
                    )
                    return False

                # Recompute hash and verify
                entry = AuditLogEntry(
                    event_type=entry_dict["event_type"],
                    actor=entry_dict["actor"],
                    resource=entry_dict["resource"],
                    action=entry_dict["action"],
                    result=entry_dict["result"],
                    details=entry_dict.get("details", {}),
                    previous_hash=entry_dict.get("previous_hash")
                )

                if entry.hash != entry_dict["hash"]:
                    logger.error(
                        "audit_log_integrity_failure",
                        line_number=i + 1,
                        reason="hash_mismatch"
                    )
                    return False

                previous_hash = entry.hash

            logger.info("audit_log_integrity_verified", entries=len(lines))
            return True

        except Exception as e:
            logger.error("audit_log_verification_failed", error=str(e))
            return False


# ============================================================================
# GLOBAL AUDIT LOGGER INSTANCE
# ============================================================================

audit_logger = AuditLogger()


# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def audit_log(
        event_type: str,
        actor: str,
        resource: str,
        action: str,
        result: str,
        **details
):
    """
    Convenience function for audit app_logging.

    Usage:
        audit_log(
            event_type="data_access",
            actor="user:123",
            resource="patient:456",
            action="read",
            result="success",
            ip_address="1.2.3.4"
        )
    """
    audit_logger.log(
        event_type=event_type,
        actor=actor,
        resource=resource,
        action=action,
        result=result,
        details=details
    )


def audit_data_access(actor: str, resource: str, action: str, success: bool, **details):
    """Log data access event"""
    audit_log(
        event_type="data_access",
        actor=actor,
        resource=resource,
        action=action,
        result="success" if success else "failure",
        **details
    )


def audit_authentication(actor: str, success: bool, **details):
    """Log authentication event"""
    audit_log(
        event_type="authentication",
        actor=actor,
        resource="auth_system",
        action="login",
        result="success" if success else "failure",
        **details
    )


def audit_authorization(actor: str, resource: str, action: str, granted: bool, **details):
    """Log authorization event"""
    audit_log(
        event_type="authorization",
        actor=actor,
        resource=resource,
        action=action,
        result="granted" if granted else "denied",
        **details
    )


def audit_data_modification(actor: str, resource: str, action: str, **details):
    """Log data modification event"""
    audit_log(
        event_type="data_modification",
        actor=actor,
        resource=resource,
        action=action,
        result="success",
        **details
    )


# ============================================================================
# EXAMPLE USAGE
# ============================================================================

"""
# In your code:

from app_logging.audit import audit_data_access, audit_authentication, audit_authorization

# Log data access
audit_data_access(
    actor="user:123",
    resource="medical_record:456",
    action="read",
    success=True,
    ip_address="1.2.3.4"
)

# Log authentication
audit_authentication(
    actor="user:123",
    success=True,
    method="password",
    ip_address="1.2.3.4"
)

# Log authorization check
audit_authorization(
    actor="user:123",
    resource="admin_panel",
    action="access",
    granted=False,
    reason="insufficient_permissions"
)

# Verify audit log integrity (run periodically)
from app_logging.audit import audit_logger
is_valid = audit_logger.verify_integrity()
"""