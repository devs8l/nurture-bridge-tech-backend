"""
Structured Logging Module
Using structlog for production-grade app_logging

Features:
- JSON structured logs
- Correlation ID tracking
- PII/PHI masking
- Context propagation
- Performance tracking

Generated by inquantic-foundry
"""

import structlog
import logging
import sys
from typing import Any, Dict
from fastapi import Request
from asgi_correlation_id import correlation_id

from config.settings import settings


# ============================================================================
# STRUCTLOG CONFIGURATION
# ============================================================================

def add_correlation_id(logger, method_name, event_dict):
    """Add correlation ID to log entries"""
    correlation = correlation_id.get()
    if correlation:
        event_dict["correlation_id"] = correlation
    return event_dict


def add_timestamp(logger, method_name, event_dict):
    """Add ISO timestamp to log entries"""
    from datetime import datetime
    event_dict["timestamp"] = datetime.utcnow().isoformat() + "Z"
    return event_dict


def mask_pii(logger, method_name, event_dict):
    """
    Mask PII/PHI in logs (HIPAA/GDPR compliance).

    Masks common PII fields like:
    - email
    - phone
    - ssn
    - credit_card
    - password
    """
    if not settings.PII_MASK_LOGS:
        return event_dict

    sensitive_fields = [
        "password", "token", "secret", "api_key",
        "ssn", "social_security", "credit_card", "card_number",
        "email", "phone", "phone_number", "address"
    ]

    def mask_value(value):
        """Mask sensitive value"""
        if not isinstance(value, str):
            return value
        if len(value) < 4:
            return "***"
        return value[:2] + "*" * (len(value) - 4) + value[-2:]

    def mask_dict(d):
        """Recursively mask dictionary values"""
        if not isinstance(d, dict):
            return d

        masked = {}
        for key, value in d.items():
            if any(field in key.lower() for field in sensitive_fields):
                masked[key] = mask_value(str(value))
            elif isinstance(value, dict):
                masked[key] = mask_dict(value)
            elif isinstance(value, list):
                masked[key] = [mask_dict(item) if isinstance(item, dict) else item for item in value]
            else:
                masked[key] = value
        return masked

    return mask_dict(event_dict)


# Configure structlog
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        add_correlation_id,
        add_timestamp,
        mask_pii,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer() if settings.LOG_FORMAT == "json"
        else structlog.dev.ConsoleRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)


# ============================================================================
# LOGGER FACTORY
# ============================================================================

def get_logger(name: str = None) -> structlog.BoundLogger:
    """
    Get a structured logger instance.

    Usage:
        logger = get_logger(__name__)
        logger.info("user_login", user_id="123", ip="1.2.3.4")

    Args:
        name: Logger name (typically __name__)

    Returns:
        Configured structlog logger
    """
    # Configure standard app_logging
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=getattr(logging, settings.LOG_LEVEL.upper())
    )

    return structlog.get_logger(name)


# ============================================================================
# REQUEST LOGGING
# ============================================================================

def log_request(request: Request):
    """
    Log incoming HTTP request with safe data extraction.

    Args:
        request: FastAPI Request object
    """
    logger = get_logger("http")

    # Extract safe request data (no PII)
    logger.info(
        "request_received",
        method=request.method,
        path=request.url.path,
        user_agent=request.headers.get("user-agent", "unknown"),
        client_host=request.client.host if request.client else "unknown",
        correlation_id=request.headers.get("X-Request-ID")
    )


# ============================================================================
# PERFORMANCE LOGGING
# ============================================================================

class LogTimer:
    """
    Context manager for timing operations.

    Usage:
        with LogTimer("database_query", user_id="123"):
            result = await db.query()
    """

    def __init__(self, operation: str, **kwargs):
        self.operation = operation
        self.context = kwargs
        self.logger = get_logger("performance")
        self.start_time = None

    def __enter__(self):
        import time
        self.start_time = time.time()
        self.logger.info(
            f"{self.operation}_started",
            **self.context
        )
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        duration = time.time() - self.start_time

        if exc_type:
            self.logger.error(
                f"{self.operation}_failed",
                duration_ms=round(duration * 1000, 2),
                error_type=exc_type.__name__,
                error=str(exc_val),
                **self.context
            )
        else:
            self.logger.info(
                f"{self.operation}_completed",
                duration_ms=round(duration * 1000, 2),
                **self.context
            )


# ============================================================================
# SECURITY EVENT LOGGING
# ============================================================================

def log_security_event(
        event_type: str,
        severity: str,
        user_id: str = None,
        details: Dict[str, Any] = None
):
    """
    Log security events (failed logins, permission denials, etc.)

    Args:
        event_type: Type of security event
        severity: low, medium, high, critical
        user_id: User involved (if applicable)
        details: Additional event details
    """
    logger = get_logger("security")

    log_data = {
        "event_type": event_type,
        "severity": severity,
        "user_id": user_id,
        **(details or {})
    }

    if severity in ["high", "critical"]:
        logger.error("security_event", **log_data)
    elif severity == "medium":
        logger.warning("security_event", **log_data)
    else:
        logger.info("security_event", **log_data)


# ============================================================================
# EXAMPLE USAGE
# ============================================================================

"""
# In your code:

from app_logging.logger import get_logger, LogTimer, log_security_event

logger = get_logger(__name__)

# Basic app_logging
logger.info("user_registered", user_id="123", email="user@example.com")

# Error app_logging
try:
    risky_operation()
except Exception as e:
    logger.error("operation_failed", error=str(e), user_id="123")

# Performance timing
with LogTimer("database_query", query="SELECT * FROM users"):
    result = await db.execute(query)

# Security app_logging
log_security_event(
    event_type="failed_login",
    severity="medium",
    user_id="123",
    details={"ip": "1.2.3.4", "attempts": 3}
)
"""