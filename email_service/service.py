"""
Email Service Module
Zero-Trust Email Communication

Provides async/sync SMTP email sending with templating support.
Generated by inquantic-foundry
"""

import asyncio
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from typing import List, Optional, Union
from pathlib import Path

import aiosmtplib
from structlog import get_logger

from config.settings import settings
from email.templates import render_template

logger = get_logger(__name__)


class EmailService:
    """
    Production-ready email service with async/sync support.
    """

    def __init__(self):
        self.host = settings.SMTP_HOST
        self.port = settings.SMTP_PORT
        self.username = settings.SMTP_USERNAME
        self.password = settings.SMTP_PASSWORD
        self.use_tls = settings.SMTP_USE_TLS
        self.use_ssl = settings.SMTP_USE_SSL
        self.from_email = settings.SMTP_FROM_EMAIL
        self.from_name = settings.SMTP_FROM_NAME
        self.timeout = settings.SMTP_TIMEOUT

    def _create_message(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        cc: Optional[List[str]] = None,
        bcc: Optional[List[str]] = None,
        attachments: Optional[List[Path]] = None,
    ) -> MIMEMultipart:
        """Create MIME message with HTML/text bodies and attachments."""
        msg = MIMEMultipart("alternative")
        msg["From"] = f"{self.from_name} <{self.from_email}>"
        msg["To"] = to_email if isinstance(to_email, str) else ", ".join(to_email)
        msg["Subject"] = subject

        if cc:
            msg["Cc"] = ", ".join(cc)
        if bcc:
            msg["Bcc"] = ", ".join(bcc)

        # Add text and HTML parts
        if text_body:
            msg.attach(MIMEText(text_body, "plain"))
        msg.attach(MIMEText(html_body, "html"))

        # Add attachments
        if attachments:
            for file_path in attachments:
                with open(file_path, "rb") as f:
                    part = MIMEBase("application", "octet-stream")
                    part.set_payload(f.read())
                    encoders.encode_base64(part)
                    part.add_header(
                        "Content-Disposition",
                        f"attachment; filename= {file_path.name}",
                    )
                    msg.attach(part)

        return msg

    async def send_async(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        cc: Optional[List[str]] = None,
        bcc: Optional[List[str]] = None,
        attachments: Optional[List[Path]] = None,
    ) -> bool:
        """
        Send email asynchronously.

        Args:
            to_email: Recipient email(s)
            subject: Email subject
            html_body: HTML email body
            text_body: Plain text fallback
            cc: CC recipients
            bcc: BCC recipients
            attachments: List of file paths to attach

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            msg = self._create_message(
                to_email, subject, html_body, text_body, cc, bcc, attachments
            )

            recipients = [to_email] if isinstance(to_email, str) else to_email
            if cc:
                recipients.extend(cc)
            if bcc:
                recipients.extend(bcc)

            if self.use_ssl:
                smtp = aiosmtplib.SMTP(
                    hostname=self.host,
                    port=self.port,
                    use_tls=False,
                    timeout=self.timeout,
                )
            else:
                smtp = aiosmtplib.SMTP(
                    hostname=self.host,
                    port=self.port,
                    use_tls=False,
                    timeout=self.timeout,
                )

            await smtp.connect()

            if self.use_tls:
                await smtp.starttls()

            if self.username and self.password:
                await smtp.login(self.username, self.password)

            await smtp.send_message(msg)
            await smtp.quit()

            logger.info(
                "email_sent",
                to=to_email,
                subject=subject,
                method="async",
            )
            return True

        except Exception as e:
            logger.error(
                "email_send_failed",
                to=to_email,
                subject=subject,
                error=str(e),
                method="async",
            )
            return False

    def send_sync(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        cc: Optional[List[str]] = None,
        bcc: Optional[List[str]] = None,
        attachments: Optional[List[Path]] = None,
    ) -> bool:
        """
        Send email synchronously.

        Args:
            to_email: Recipient email(s)
            subject: Email subject
            html_body: HTML email body
            text_body: Plain text fallback
            cc: CC recipients
            bcc: BCC recipients
            attachments: List of file paths to attach

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            msg = self._create_message(
                to_email, subject, html_body, text_body, cc, bcc, attachments
            )

            recipients = [to_email] if isinstance(to_email, str) else to_email
            if cc:
                recipients.extend(cc)
            if bcc:
                recipients.extend(bcc)

            if self.use_ssl:
                smtp = smtplib.SMTP_SSL(self.host, self.port, timeout=self.timeout)
            else:
                smtp = smtplib.SMTP(self.host, self.port, timeout=self.timeout)

            if self.use_tls and not self.use_ssl:
                smtp.starttls()

            if self.username and self.password:
                smtp.login(self.username, self.password)

            smtp.send_message(msg)
            smtp.quit()

            logger.info(
                "email_sent",
                to=to_email,
                subject=subject,
                method="sync",
            )
            return True

        except Exception as e:
            logger.error(
                "email_send_failed",
                to=to_email,
                subject=subject,
                error=str(e),
                method="sync",
            )
            return False

    async def send_template_async(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        template_name: str,
        context: dict,
        **kwargs,
    ) -> bool:
        """
        Send email using a template (async).

        Args:
            to_email: Recipient email(s)
            subject: Email subject
            template_name: Template file name (e.g., 'welcome.html')
            context: Template context variables
            **kwargs: Additional arguments for send_async

        Returns:
            True if sent successfully
        """
        html_body = render_template(template_name, context)
        return await self.send_async(to_email, subject, html_body, **kwargs)

    def send_template_sync(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        template_name: str,
        context: dict,
        **kwargs,
    ) -> bool:
        """
        Send email using a template (sync).

        Args:
            to_email: Recipient email(s)
            subject: Email subject
            template_name: Template file name (e.g., 'welcome.html')
            context: Template context variables
            **kwargs: Additional arguments for send_sync

        Returns:
            True if sent successfully
        """
        html_body = render_template(template_name, context)
        return self.send_sync(to_email, subject, html_body, **kwargs)


# Singleton instance
email_service = EmailService()


# Convenience functions
async def send_email_async(*args, **kwargs):
    """Convenience function for async email sending."""
    return await email_service.send_async(*args, **kwargs)


def send_email(*args, **kwargs):
    """Convenience function for sync email sending."""
    return email_service.send_sync(*args, **kwargs)


async def send_template_email_async(*args, **kwargs):
    """Convenience function for async template email sending."""
    return await email_service.send_template_async(*args, **kwargs)


def send_template_email(*args, **kwargs):
    """Convenience function for sync template email sending."""
    return email_service.send_template_sync(*args, **kwargs)
