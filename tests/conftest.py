"""
Pytest Configuration and Fixtures
Shared test fixtures and configuration

Generated by inquantic-foundry
"""

import pytest
import asyncio
from typing import AsyncGenerator, Generator
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import NullPool

from app.main import app
from db.base import Base, get_db
from config.settings import settings


# ============================================================================
# EVENT LOOP FIXTURE
# ============================================================================

@pytest.fixture(scope="session")
def event_loop() -> Generator:
    """Create event loop for async tests"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# ============================================================================
# DATABASE FIXTURES
# ============================================================================

# Test database URL (use in-memory SQLite or separate test database)
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"


# Or use: "postgresql+asyncpg://test:test@localhost:5432/test_db"

@pytest.fixture(scope="session")
async def test_engine():
    """Create test database engine"""
    engine = create_async_engine(
        TEST_DATABASE_URL,
        echo=False,
        poolclass=NullPool,
    )

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()


@pytest.fixture
async def test_session(test_engine) -> AsyncGenerator[AsyncSession, None]:
    """Create test database session"""
    async_session_maker = async_sessionmaker(
        test_engine,
        class_=AsyncSession,
        expire_on_commit=False,
        autocommit=False,
        autoflush=False,
    )

    async with async_session_maker() as session:
        yield session
        await session.rollback()


# ============================================================================
# HTTP CLIENT FIXTURE
# ============================================================================

@pytest.fixture
async def client(test_session: AsyncSession) -> AsyncGenerator[AsyncClient, None]:
    """
    Create HTTP client for testing API endpoints.

    Usage:
        async def test_health(client):
            response = await client.get("/api/v1/health")
            assert response.status_code == 200
    """

    # Override database dependency
    async def override_get_db():
        yield test_session

    app.dependency_overrides[get_db] = override_get_db

    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

    app.dependency_overrides.clear()


# ============================================================================
# AUTHENTICATION FIXTURES
# ============================================================================

@pytest.fixture
def test_user_data() -> dict:
    """Test user data"""
    return {
        "email": "test@example.com",
        "username": "testuser",
        "password": "TestPassword123!",
        "full_name": "Test User"
    }


@pytest.fixture
async def test_user(test_session: AsyncSession, test_user_data: dict):
    """Create test user in database"""
    from db.models.auth import User, UserRole, UserStatus
    from app.core.security import hash_password

    user = User(
        email=test_user_data["email"],
        name=test_user_data.get("full_name", "Test User"),
        password_hash=hash_password(test_user_data["password"]),
        role=UserRole.DOCTOR,
        status=UserStatus.ACTIVE
    )

    test_session.add(user)
    await test_session.commit()
    await test_session.refresh(user)

    return user


@pytest.fixture
async def auth_token(test_user) -> str:
    """Generate authentication token for test user"""
    from security.auth import create_access_token

    token = create_access_token(
        data={
            "sub": test_user.id,
            "email": test_user.email,
            "roles": []
        }
    )

    return token


@pytest.fixture
async def authenticated_client(
        client: AsyncClient,
        auth_token: str
) -> AsyncClient:
    """
    HTTP client with authentication headers.

    Usage:
        async def test_protected_endpoint(authenticated_client):
            response = await authenticated_client.get("/api/v1/protected")
            assert response.status_code == 200
    """
    client.headers.update({"Authorization": f"Bearer {auth_token}"})
    return client


# ============================================================================
# ADMIN USER FIXTURES
# ============================================================================

@pytest.fixture
async def admin_user(test_session: AsyncSession):
    """Create admin user for testing"""
    from db.models.auth import User, UserRole, UserStatus
    from app.core.security import hash_password

    admin = User(
        email="admin@example.com",
        name="NBT_super_admin",
        password_hash=hash_password("AdminPassword123!"),
        role=UserRole.SUPER_ADMIN,
        status=UserStatus.ACTIVE
    )

    test_session.add(admin)
    await test_session.commit()
    await test_session.refresh(admin)

    return admin


@pytest.fixture
async def admin_token(admin_user) -> str:
    """Generate admin authentication token"""
    from security.auth import create_access_token

    token = create_access_token(
        data={
            "sub": admin_user.id,
            "email": admin_user.email,
            "roles": ["admin"]
        }
    )

    return token


@pytest.fixture
async def admin_client(client: AsyncClient, admin_token: str) -> AsyncClient:
    """HTTP client with admin authentication"""
    client.headers.update({"Authorization": f"Bearer {admin_token}"})
    return client


# ============================================================================
# DATA FIXTURES
# ============================================================================

@pytest.fixture
async def sample_posts(test_session: AsyncSession, test_user):
    """Create sample posts for testing"""
    from db.models import Post

    posts = [
        Post(
            title=f"Test Post {i}",
            content=f"Content for test post {i}",
            author_id=test_user.id,
            is_published=True if i % 2 == 0 else False
        )
        for i in range(5)
    ]

    for post in posts:
        test_session.add(post)

    await test_session.commit()

    for post in posts:
        await test_session.refresh(post)

    return posts


# ============================================================================
# MOCK FIXTURES
# ============================================================================

@pytest.fixture
def mock_redis(monkeypatch):
    """Mock Redis for testing"""

    class MockRedis:
        def __init__(self):
            self.data = {}

        async def get(self, key):
            return self.data.get(key)

        async def set(self, key, value, ex=None):
            self.data[key] = value

        async def delete(self, key):
            self.data.pop(key, None)

    return MockRedis()


@pytest.fixture
def mock_celery(monkeypatch):
    """Mock Celery for testing"""

    class MockTask:
        def __init__(self, result=None):
            self.id = "test-task-id"
            self.result = result

        def get(self):
            return self.result

    class MockCelery:
        def delay(self, *args, **kwargs):
            return MockTask(result={"status": "success"})

    return MockCelery()


# ============================================================================
# CLEANUP FIXTURES
# ============================================================================

@pytest.fixture(autouse=True)
async def cleanup_database(test_session: AsyncSession):
    """Auto cleanup after each test"""
    yield
    # Rollback any uncommitted changes
    await test_session.rollback()


# ============================================================================
# CONFIGURATION OVERRIDES
# ============================================================================

@pytest.fixture(autouse=True)
def override_settings(monkeypatch):
    """Override settings for testing"""
    monkeypatch.setattr(settings, "ENVIRONMENT", "test")
    monkeypatch.setattr(settings, "DEBUG", True)
    monkeypatch.setattr(settings, "DATABASE_URL", TEST_DATABASE_URL)


# ============================================================================
# MARKERS
# ============================================================================

def pytest_configure(config):
    """Register custom markers"""
    config.addinivalue_line(
        "markers", "slow: mark test as slow running"
    )
    config.addinivalue_line(
        "markers", "integration: mark test as integration test"
    )
    config.addinivalue_line(
        "markers", "unit: mark test as unit test"
    )