"""
RBAC/ABAC Authorization Module
Using Casbin for enterprise-grade access control

Supports:
- RBAC (Role-Based Access Control)
- ABAC (Attribute-Based Access Control)
- PBAC (Policy-Based Access Control)

Generated by inquantic-foundry
"""

import casbin
from pathlib import Path
from typing import List, Optional
from fastapi import Depends, HTTPException, status

from security.auth import get_current_user
from app_logging.logger import get_logger

logger = get_logger(__name__)

# ============================================================================
# CASBIN MODEL & POLICY
# ============================================================================

# Casbin Model Definition (RBAC with resource-level permissions)
RBAC_MODEL = """
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
"""

# Default policies (can be loaded from database)
DEFAULT_POLICIES = [
    # Format: role, resource, action

    # Admin role - full access
    ["role:admin", "*", "*"],

    # User role - read access to own resources
    ["role:user", "users:self", "read"],
    ["role:user", "users:self", "update"],
    ["role:user", "data:own", "read"],
    ["role:user", "data:own", "create"],

    # Viewer role - read-only
    ["role:viewer", "data:*", "read"],

    # API role - system integration
    ["role:api", "api:*", "*"],

    # Healthcare roles (HIPAA compliance)
    ["role:doctor", "patients:*", "read"],
    ["role:doctor", "patients:*", "update"],
    ["role:doctor", "medical_records:*", "read"],
    ["role:doctor", "medical_records:*", "create"],

    ["role:nurse", "patients:*", "read"],
    ["role:nurse", "medical_records:*", "read"],

    ["role:patient", "medical_records:own", "read"],

    # Financial roles (PCI-DSS compliance)
    ["role:accountant", "transactions:*", "read"],
    ["role:finance_manager", "transactions:*", "*"],
]

# Role assignments (can be loaded from database)
DEFAULT_ROLE_ASSIGNMENTS = [
    # Format: user_id, role
    # These will be replaced with actual database-driven assignments
]


# ============================================================================
# CASBIN ENFORCER INITIALIZATION
# ============================================================================

def get_enforcer() -> casbin.Enforcer:
    """
    Initialize and return Casbin enforcer.

    In production, load policies from database instead of memory.

    Returns:
        Configured Casbin enforcer
    """
    # Create enforcer with in-memory adapter
    enforcer = casbin.Enforcer()
    enforcer.load_model_from_text(RBAC_MODEL)

    # Add default policies
    for policy in DEFAULT_POLICIES:
        enforcer.add_policy(*policy)

    # Add default role assignments
    for assignment in DEFAULT_ROLE_ASSIGNMENTS:
        enforcer.add_grouping_policy(*assignment)

    logger.info(
        "casbin_enforcer_initialized",
        policies_count=len(DEFAULT_POLICIES),
        roles_count=len(DEFAULT_ROLE_ASSIGNMENTS)
    )

    return enforcer


# Global enforcer instance
enforcer = get_enforcer()


# ============================================================================
# AUTHORIZATION FUNCTIONS
# ============================================================================

def check_permission(user_id: str, resource: str, action: str) -> bool:
    """
    Check if user has permission to perform action on resource.

    Args:
        user_id: User identifier or role
        resource: Resource identifier (e.g., "users:123", "data:*")
        action: Action to perform (e.g., "read", "write", "delete")

    Returns:
        True if permission granted, False otherwise
    """
    result = enforcer.enforce(user_id, resource, action)

    logger.info(
        "permission_check",
        user_id=user_id,
        resource=resource,
        action=action,
        result="granted" if result else "denied"
    )

    return result


def check_role_permission(role: str, resource: str, action: str) -> bool:
    """
    Check if role has permission to perform action on resource.

    Args:
        role: Role identifier (e.g., "role:admin")
        resource: Resource identifier
        action: Action to perform

    Returns:
        True if permission granted, False otherwise
    """
    return check_permission(f"role:{role}", resource, action)


def get_user_roles(user_id: str) -> List[str]:
    """
    Get all roles assigned to user.

    Args:
        user_id: User identifier

    Returns:
        List of role names
    """
    roles = enforcer.get_roles_for_user(user_id)

    logger.info("roles_retrieved", user_id=user_id, roles=roles)

    return roles


def assign_role_to_user(user_id: str, role: str) -> bool:
    """
    Assign role to user.

    Args:
        user_id: User identifier
        role: Role to assign (e.g., "role:admin")

    Returns:
        True if successful
    """
    result = enforcer.add_grouping_policy(user_id, role)

    if result:
        logger.info("role_assigned", user_id=user_id, role=role)
    else:
        logger.warning("role_assignment_failed", user_id=user_id, role=role)

    return result


def remove_role_from_user(user_id: str, role: str) -> bool:
    """
    Remove role from user.

    Args:
        user_id: User identifier
        role: Role to remove

    Returns:
        True if successful
    """
    result = enforcer.remove_grouping_policy(user_id, role)

    if result:
        logger.info("role_removed", user_id=user_id, role=role)
    else:
        logger.warning("role_removal_failed", user_id=user_id, role=role)

    return result


def add_policy(role: str, resource: str, action: str) -> bool:
    """
    Add new policy to the system.

    Args:
        role: Role or user identifier
        resource: Resource pattern
        action: Action allowed

    Returns:
        True if successful
    """
    result = enforcer.add_policy(role, resource, action)

    if result:
        logger.info("policy_added", role=role, resource=resource, action=action)
    else:
        logger.warning("policy_add_failed", role=role, resource=resource, action=action)

    return result


def remove_policy(role: str, resource: str, action: str) -> bool:
    """
    Remove policy from the system.

    Args:
        role: Role or user identifier
        resource: Resource pattern
        action: Action to remove

    Returns:
        True if successful
    """
    result = enforcer.remove_policy(role, resource, action)

    if result:
        logger.info("policy_removed", role=role, resource=resource, action=action)
    else:
        logger.warning("policy_removal_failed", role=role, resource=resource, action=action)

    return result


# ============================================================================
# FASTAPI DEPENDENCIES
# ============================================================================

def require_permission(resource: str, action: str):
    """
    FastAPI dependency factory for permission checking.

    Usage:
        @app.get("/admin", dependencies=[Depends(require_permission("admin:panel", "read"))])
        async def admin_panel():
            return {"message": "Admin access granted"}

    Args:
        resource: Resource to check
        action: Action to check

    Returns:
        FastAPI dependency function
    """

    async def permission_checker(current_user: dict = Depends(get_current_user)):
        user_id = current_user.get("sub")
        roles = current_user.get("roles", [])

        # Check user-specific permission
        if check_permission(user_id, resource, action):
            return current_user

        # Check role-based permissions
        for role in roles:
            if check_permission(f"role:{role}", resource, action):
                return current_user

        logger.warning(
            "permission_denied",
            user_id=user_id,
            resource=resource,
            action=action,
            roles=roles
        )

        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Permission denied: {action} on {resource}"
        )

    return permission_checker


def require_role(required_role: str):
    """
    FastAPI dependency factory for role checking.

    Usage:
        @app.get("/admin", dependencies=[Depends(require_role("admin"))])
        async def admin_only():
            return {"message": "Admin only"}

    Args:
        required_role: Role required (without "role:" prefix)

    Returns:
        FastAPI dependency function
    """

    async def role_checker(current_user: dict = Depends(get_current_user)):
        user_roles = current_user.get("roles", [])

        if required_role in user_roles:
            return current_user

        logger.warning(
            "role_check_failed",
            user_id=current_user.get("sub"),
            required_role=required_role,
            user_roles=user_roles
        )

        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Role '{required_role}' required"
        )

    return role_checker


# ============================================================================
# EXAMPLE USAGE IN ROUTES
# ============================================================================

"""
# In your router file:

from fastapi import APIRouter, Depends
from security.rbac import require_permission, require_role

router = APIRouter()

# Require specific permission
@router.get("/patients/{patient_id}", dependencies=[Depends(require_permission("patients:*", "read"))])
async def get_patient(patient_id: str):
    return {"patient_id": patient_id}

# Require specific role
@router.get("/admin/dashboard", dependencies=[Depends(require_role("admin"))])
async def admin_dashboard():
    return {"message": "Admin dashboard"}

# Check permission in route logic
@router.post("/data")
async def create_data(current_user: dict = Depends(get_current_user)):
    user_id = current_user["sub"]

    if not check_permission(user_id, "data:own", "create"):
        raise HTTPException(status_code=403, detail="Permission denied")

    # Create data...
    return {"message": "Data created"}
"""