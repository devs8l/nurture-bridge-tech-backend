"""
Authentication Module
OAuth2 / JWT Implementation using Authlib

OWASP ASVS 4.0 Compliant
Zero-Trust Security Model

Generated by inquantic-foundry
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from authlib.jose import jwt, JoseError
from passlib.context import CryptContext
from pydantic import BaseModel, EmailStr

from config.settings import settings
from app_logging.logger import get_logger

logger = get_logger(__name__)

# ============================================================================
# PASSWORD HASHING (Argon2 - OWASP Recommended)
# ============================================================================

pwd_context = CryptContext(
    schemes=["argon2", "bcrypt"],
    deprecated="auto",
    argon2__memory_cost=65536,  # 64 MB
    argon2__time_cost=3,
    argon2__parallelism=4
)


def hash_password(password: str) -> str:
    """
    Hash password using Argon2.

    Args:
        password: Plain text password

    Returns:
        Hashed password string
    """
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify password against hash.

    Args:
        plain_password: Plain text password to verify
        hashed_password: Stored hash

    Returns:
        True if password matches, False otherwise
    """
    return pwd_context.verify(plain_password, hashed_password)


# ============================================================================
# JWT TOKEN MODELS
# ============================================================================

class TokenPayload(BaseModel):
    """JWT token payload structure"""
    sub: str  # Subject (user ID)
    exp: datetime  # Expiration
    iat: datetime  # Issued at
    type: str  # Token type (access or refresh)
    email: Optional[EmailStr] = None
    roles: list[str] = []
    permissions: list[str] = []


class TokenResponse(BaseModel):
    """Token response model"""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int


# ============================================================================
# JWT TOKEN GENERATION
# ============================================================================

def create_access_token(
        data: Dict[str, Any],
        expires_delta: Optional[timedelta] = None
) -> str:
    """
    Create JWT access token.

    Args:
        data: Payload data to encode
        expires_delta: Token expiration time

    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow(),
        "type": "access"
    })

    header = {"alg": settings.JWT_ALGORITHM}

    try:
        encoded_jwt = jwt.encode(
            header,
            to_encode,
            settings.JWT_SECRET_KEY
        )

        logger.info(
            "access_token_created",
            user_id=data.get("sub"),
            expires_at=expire.isoformat()
        )

        return encoded_jwt.decode("utf-8")

    except Exception as e:
        logger.error("token_creation_failed", error=str(e))
        raise


def create_refresh_token(user_id: str) -> str:
    """
    Create JWT refresh token.

    Args:
        user_id: User identifier

    Returns:
        Encoded JWT refresh token
    """
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)

    payload = {
        "sub": user_id,
        "exp": expire,
        "iat": datetime.utcnow(),
        "type": "refresh"
    }

    header = {"alg": settings.JWT_ALGORITHM}

    try:
        encoded_jwt = jwt.encode(
            header,
            payload,
            settings.JWT_SECRET_KEY
        )

        logger.info(
            "refresh_token_created",
            user_id=user_id,
            expires_at=expire.isoformat()
        )

        return encoded_jwt.decode("utf-8")

    except Exception as e:
        logger.error("refresh_token_creation_failed", error=str(e))
        raise


def create_token_pair(user_id: str, email: str, roles: list[str] = None) -> TokenResponse:
    """
    Create access and refresh token pair.

    Args:
        user_id: User identifier
        email: User email
        roles: User roles

    Returns:
        TokenResponse with both tokens
    """
    roles = roles or []

    access_token = create_access_token(
        data={
            "sub": user_id,
            "email": email,
            "roles": roles
        }
    )

    refresh_token = create_refresh_token(user_id)

    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )


# ============================================================================
# JWT TOKEN VERIFICATION
# ============================================================================

def decode_token(token: str) -> Dict[str, Any]:
    """
    Decode and verify JWT token.

    Args:
        token: JWT token string

    Returns:
        Decoded token payload

    Raises:
        HTTPException: If token is invalid or expired
    """
    try:
        payload = jwt.decode(token, settings.JWT_SECRET_KEY)

        # Verify token type
        if payload.get("type") != "access":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token type"
            )

        # Verify expiration
        exp = payload.get("exp")
        if exp and datetime.fromtimestamp(exp) < datetime.utcnow():
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )

        logger.info("token_verified", user_id=payload.get("sub"))

        return payload

    except JoseError as e:
        logger.warning("token_verification_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )


# ============================================================================
# FASTAPI DEPENDENCIES
# ============================================================================

security = HTTPBearer()


async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict[str, Any]:
    """
    FastAPI dependency to get current authenticated user.

    Usage:
        @app.get("/protected")
        async def protected_route(user: dict = Depends(get_current_user)):
            return {"user_id": user["sub"]}

    Args:
        credentials: HTTP Bearer token from request

    Returns:
        Decoded token payload (user info)

    Raises:
        HTTPException: If authentication fails
    """
    token = credentials.credentials
    payload = decode_token(token)

    # TODO: Optionally verify user still exists in database
    # user = await get_user_from_db(payload["sub"])
    # if not user:
    #     raise HTTPException(status_code=401, detail="User not found")

    return payload


async def get_current_active_user(
        current_user: Dict[str, Any] = Depends(get_current_user)
) -> Dict[str, Any]:
    """
    Get current active user (can add additional checks here).

    Args:
        current_user: User from get_current_user

    Returns:
        User data if active

    Raises:
        HTTPException: If user is inactive
    """
    # TODO: Add checks for user status (active, suspended, etc.)
    # if current_user.get("status") == "suspended":
    #     raise HTTPException(status_code=403, detail="Account suspended")

    return current_user


# ============================================================================
# AUTHENTICATION FUNCTIONS
# ============================================================================

async def authenticate_user(email: str, password: str) -> Optional[Dict[str, Any]]:
    """
    Authenticate user with email and password.

    TODO: Implement actual database lookup.

    Args:
        email: User email
        password: Plain text password

    Returns:
        User data if authentication succeeds, None otherwise
    """
    # TODO: Replace with actual database query
    # user = await db.users.find_one({"email": email})
    # if not user:
    #     logger.warning("authentication_failed", email=email, reason="user_not_found")
    #     return None
    #
    # if not verify_password(password, user["password_hash"]):
    #     logger.warning("authentication_failed", email=email, reason="invalid_password")
    #     return None
    #
    # logger.info("authentication_successful", user_id=user["id"])
    # return user

    # Placeholder for testing
    logger.warning("authenticate_user_not_implemented")
    return None


# ============================================================================
# EXAMPLE USAGE IN ROUTES
# ============================================================================

"""
# In your router file:

from fastapi import APIRouter, Depends
from security.auth import get_current_user, create_token_pair, authenticate_user

router = APIRouter()

@router.post("/login")
async def login(email: str, password: str):
    user = await authenticate_user(email, password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    tokens = create_token_pair(
        user_id=user["id"],
        email=user["email"],
        roles=user.get("roles", [])
    )

    return tokens

@router.get("/me")
async def get_me(current_user: dict = Depends(get_current_user)):
    return {"user": current_user}

@router.get("/protected")
async def protected_endpoint(current_user: dict = Depends(get_current_user)):
    return {"message": "Access granted", "user_id": current_user["sub"]}
"""